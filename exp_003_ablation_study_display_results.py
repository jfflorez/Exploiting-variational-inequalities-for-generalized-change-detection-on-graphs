from genericpath import exists
import matplotlib.pyplot as plt
import numpy as np
import pickle
import pandas as pd
import os 

""" Display previously computed results from experiment in Sec. VI-D Ablation study on the number of superpixels and structure
learning algorithm. """

dirname = os.path.dirname(__file__)
datasets_dir = os.path.join(dirname, 'datasets')
####


out_fn = lambda db_idx,db_name, ext: 'Exp_003_ablation_study_on_db_'+ str(db_idx) + '_' + db_name + ext
results_dir = os.path.join(dirname, 'results')
results_dir = os.path.join(results_dir,'ablation_study')


def unpack_ablation_study_results(filename_format,list_of_configs,dict_name,norm):

    for config in list_of_configs:
        file_name = filename_format.format(i=config[2],scheme=config[3],db=config[0],glmodel=config[1],
                        dict_name=dict_name,norm=norm)
        if os.path.isfile(os.path.join(results_dir,file_name+'.pkl')):
            with open(os.path.join(results_dir,file_name+'.pkl'), 'rb') as f:
                file_data = pickle.load(f)
            
            new_row = {'n_spixels_ref': file_data['num_spixels_ref'],
                    'n_spixels': file_data['num_slic_spixels'],
                    'dataset'  : config[0],
                    'gl_model' : config[1],
                    'scheme'   : config[3]}
            for idx in range(len(file_data['metrics_dict']['metrics_labels'])):
                new_row[file_data['metrics_dict']['metrics_labels'][idx]] = np.round(file_data['metrics_dict']['metrics'][idx],2)
            if 'table' in locals():
                table = pd.concat([table,pd.DataFrame(new_row,index=[0])],axis=0,ignore_index=True)
                #table = table.append(new_row,ignore_index=True)
            else: 
                table = pd.DataFrame(new_row,index=[0])#,columns=list(new_row.keys()))
           
    return table        
        
        #file = pickle.load(os.path.join(results_dir,file_name+'.pkl'))
        #print(':)')
#table.sort_values(['scheme','gl_model'])


def gen_color_dict(cmap_name, categorical_keys):
    """
    Parameters:
    categorical_keys (list): denotes a list of string values that will act as keys in the color
    asignment dictionary.
    """
    from matplotlib.cm import get_cmap
    cmap = get_cmap(cmap_name)
    colors = cmap(np.linspace(0, 1, len(categorical_keys)))
    color_dict = { categorical_keys[i] : colors[i,:] for i in range(len(categorical_keys))}

    return color_dict

def create_barplot(db_name,df,num_features, in_cat_feature, out_cat_feature,save_dir):    
    # create len(out_barplot_cat) independent barplots

    # Set the colormap
    cmap_name = 'tab20'
    from matplotlib.cm import get_cmap
    cmap = get_cmap(cmap_name)
    
    out_cat_values = df.loc[:,out_cat_feature].unique()
    in_cat_values = df.loc[:,in_cat_feature].unique()
    color_dict = gen_color_dict(cmap_name, in_cat_values)

    x_axis = np.arange(len(num_features))
    width = 0.4
    
    for out_c_val in out_cat_values: # outer categories loop
        # reduce rows to those with outer category c
        tmp = df.loc[df.loc[:,out_cat_feature]==out_c_val,:]
        #in_cat_values = df.loc[:,in_cat_feature].unique()
        #colors = cmap(np.linspace(0, 1, len(in_cat_values)))
        #color_dict = { in_cat_values[i] : colors[i,:] for i in range(len(in_cat_values))}
        
        num_bars = len(in_cat_values)
        # compute bar centers
        if num_bars == 2:
            barwidth = 0.4
            bar_shift = { in_cat_values[0] : -0.2,  in_cat_values[1]: 0.2}
        else: # TODO: generalize to more bars
            barwidth = 0.8 # default value
            bar_shift = { in_cat_values[i] : 0 for i in range(len(in_cat_values))}
        fig, ax = plt.subplots()
        for in_c_val in in_cat_values:
            filter = tmp.loc[:,in_cat_feature] == in_c_val
            avg_num_features = tmp.loc[filter,num_features].mean(axis=0).to_numpy()
            std_num_features = tmp.loc[filter,num_features].std(axis=0).to_numpy()        
            ax.bar(x = x_axis + bar_shift[in_c_val], width = barwidth, height=avg_num_features, yerr=std_num_features, label = in_c_val,color=color_dict[in_c_val])
            
            if not 'yticks' in locals():
                yticks = avg_num_features
            else:
                yticks = np.maximum(avg_num_features, yticks)

        plt.xticks(x_axis, num_features, fontsize=20, rotation=45)
        #ax.set_yticks(np.round(yticks,2))
        ax.set_yticks(np.linspace(0,1,5))
        ax.set_ylim(0,1)
        ax.set_box_aspect(1)
        #ax.set_yscale('log')
        ax.legend(loc="best")
        ax.set_ylabel('Avg. value', fontsize = 20)        
        ax.set_title(out_c_val,fontdict={'fontsize':20})

        plt.savefig(save_dir + "\\fig_ablation_bar_imgs_"+ "_{db}_{schm}_".format(db=db_name,schm=out_c_val) + ".png", dpi=DPI, bbox_inches='tight')

        #return fig, ax

def plot_num_feature(db_name, df,x_num_feature,y_num_feature, in_categ_feature, out_categ_feature,save_dir):
    """ creates a subplot of size (1,num_categ_values), where num_categ_values is given by
    the unique values of the column 'out_categ_feature' in df. Each subplot consists of curves
    associated with the different categories in 'in_categ_feature'.
    
    Paramters:
    df (dataframe): denotes a table with numerical and categorical features
    x_num_feature,y_num_feature, in_categ_feature, out_categ_feature (string): denote strings
    in the columns of df.
    """

    in_categ_values = df[in_categ_feature].unique()
    cmap_name = 'rainbow'
    color_dict = gen_color_dict(cmap_name, list(in_categ_values))
    #marker = {'Kalofolias':'ro--','MST_with_binary_weights':'bs-'}
    #import itertools
    available_markers = ['o--', '+-', 's', ',', '*']
    markers = {in_categ_values[i]:available_markers[i % len(available_markers)] for i in range(len(in_categ_values))}

    out_categ_values = df[out_categ_feature].unique()
    fig,ax = plt.subplots(1,len(out_categ_values), figsize=(10, 10), sharey=True, sharex=True)
    for idx_sch in range(len(out_categ_values)):
        table_scheme = df.loc[table.loc[:,out_categ_feature]== out_categ_values[idx_sch],:]
        for gl_name in df[in_categ_feature].unique():
            x = table_scheme.loc[table_scheme.loc[:,in_categ_feature]==gl_name, x_num_feature]
            y = table_scheme.loc[table_scheme.loc[:,in_categ_feature]==gl_name, y_num_feature]
            #ax[idx_metric,idx_sch].semilogx(x,y,marker[gl_name],label=gl_name + '({scheme})'.format(scheme=schemes[idx_sch]),
            #                        color=color[schemes[idx_sch]])
            ax[idx_sch].set_box_aspect(1)
            ax[idx_sch].semilogx(x,y,markers[gl_name],color=color_dict[gl_name],label=gl_name)
            ax[idx_sch].set_title(out_categ_values[idx_sch],fontdict = {'fontsize':20})
        ax[idx_sch].legend(loc='best', borderaxespad=0., fontsize = 'small')#,ncol=4)


        ax[idx_sch].set_xlabel(x_num_feature, fontsize = 20)
        ax[idx_sch].set_ylabel(y_num_feature, fontsize = 20)

    plt.savefig(save_dir + "\\fig_ablation_plots_imgs_"+ db_name + ".png", dpi=DPI, bbox_inches='tight')

    #return fig, ax


dataset_names = ['Alaska','California','Atlantico', 'Mulgaria','Toulouse','Shuguang']
dataset_names = ['Alaska','California']
gl_models = ['Kalofolias', 'MST_with_binary_weights']
num_superpixels = np.logspace(2,4,5).astype(int)
schemes = ['unsupervised','semisupervised']
list_of_configs = [(db,gl,i,scheme) for db in dataset_names for gl in gl_models for i in range(0,len(num_superpixels)) for scheme in schemes]
dict_name = 'RLP'
norm = '2'
filename_format = '{i}_{scheme}_results_on_{db}_with_{glmodel}_{dict_name}_{norm}'
table = unpack_ablation_study_results(filename_format,list_of_configs,dict_name,norm)

# Generate plots and store results in figs
DPI = 400
img_dir = "./figs\\figs_ablation_study_res_"+str(DPI)
if not os.path.exists(img_dir):
    os.mkdir(img_dir)

x_num_feature = 'Number of superpixels'
y_num_feature = 'AUC'
in_categ_feature = 'gl_model'
out_categ_feature = 'scheme' 
params = {'fontsize':15,'xlabel':'Number of superpixels','ylabel':'AUC'}
# Rename column in table so it can be accessed by x_num_feature
table = table.rename(columns={'n_spixels':'Number of superpixels'})
save_dir = img_dir

for db_name in table['dataset'].unique():

    db_filter = table['dataset']==db_name
    table_for_db = table.loc[db_filter,:]
    plot_num_feature(db_name,table_for_db,x_num_feature,y_num_feature, in_categ_feature, out_categ_feature,save_dir)

    metrics_labels = ['AUC','F1-SCORE','KAPPA','TPR_REF','FPR_REF']
    diff_barplot_cat = schemes # 'semisup', 'unsup'
    out_cat_feature = 'scheme'
    in_cat_feature = 'gl_model'
    num_features = ['AUC','F-SCORE','KAPPA','TPR_REF','FPR_REF']
    create_barplot(db_name,table_for_db,metrics_labels,in_cat_feature,out_cat_feature,save_dir)

    print('fin')




#.plot.scatter(x='n_spixels',y='F1-SCORE',c='gl_model')



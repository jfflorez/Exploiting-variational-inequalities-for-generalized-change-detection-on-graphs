import numpy as np
import scipy.sparse.linalg as sp_s_linalg
import scipy.linalg as sp_linalg

def objective(A, b, x):
    return sp_linalg.norm(x,1)

def shrinkage(a, kappa):
    return np.maximum(0, a-kappa) - np.maximum(0, -a-kappa)

def basis_pursuit(A,b,rho,alpha):    
    #t_start = tic
    # Global constants and defaults
    QUIET    = False
    MAX_ITER = 1000
    ABSTOL   = 1e-4
    RELTOL   = 1e-2

    # Data preprocessing
    m, n = A.shape

    # ADMM solver

    x = np.zeros((n,1))
    z = np.zeros((n,1))
    u = np.zeros(n,1)

    history = {}
    if np.logical_not(QUIET):
        print('r norm', 'eps pri', 's norm', 'eps dual', 'objective')

    # precompute static variables for x-update (projection on to Ax=b)
    AAt = A @ A.T
    P = np.eye(n) - A.T @ (np.sp_s_linalg.inv(AAt) @ A)
    q = A.T @ (sp_s_linalg.inv(AAt) @ b)

    for k in range(1,MAX_ITER):
        # x-update
        x = P@(z - u) + q

        # z-update with relaxation
        zold = z
        x_hat = alpha*x + (1 - alpha)*zold
        z = shrinkage(x_hat + u, 1/rho)

        u = u + (x_hat - z)

        # diagnostics, reporting, termination checks
        history['objval'][k]   = objective(A, b, x)

        history['r_norm'][k]   = sp_linalg.norm(x - z)
        history['s_norm'][k]   = sp_linalg.norm(-rho*(z - zold))

        history['eps_pri'][k]  = np.sqrt(n)*ABSTOL + RELTOL*np.maximum(sp_linalg.norm(x), sp_linalg.norm(-z))
        history['eps_dual'][k] = np.sqrt(n)*ABSTOL + RELTOL*sp_linalg.norm(rho*u)

        if np.logical_not(QUIET):
            print(history['r_norm'][k], history['eps_pri'][k], 
                  history['s_norm'][k], history['eps_dual'][k], history['objval'][k])
        

        if history['r_norm'][k] < history['eps_pri'][k] and history['s_norm'][k] < history['eps_dual'][k]:
            break
    return x

    #if ~QUIET
    #    toc(t_start);
    #end